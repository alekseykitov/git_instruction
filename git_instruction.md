![git logo](git_logo.jpeg)
# Работа с Git и GitHub

## 1. Проверка наличия установленного Git
В терминале выполнить команду `git --version`.
Если git установлен появится сообщение с информацией о версии программы. Иначе будет сообщение об ошибке.

## 2. Установка Git
Загружаем последнюю версию файла с сайта https://git-scm.com/downloads.
Устанавливаем с настройками по умолчанию

## 3. Настройка Git
При первом использовании Git необходимо представиться. Для этого нужно ввести в терминале две команды:
```
git config --global user.name «Ваше имя английскими буквами»
git config --global user.email вашапочта@example.com
```

```Py
print('Hello world')
```

## 4. Инициализация репозитория
Git хранит свои файлы и историю прямо в папке проекта. Чтобы создать новый репозиторий, нам нужно *зайти в папку нашего проекта* и выполнить команду init. Это включит приложение в этой конкретной папке и создаст скрытую директорию .git, где будет храниться история репозитория и настройки.


Когда мы находимся в нужной папке (папка проекта) вводим команду в консоль:
```
git init
```
Командная строка должна вернуть что-то вроде:
```
Initialized empty Git repository in /home/user/Desktop/git_exercise/.git/
```

## 5. Определение состояния
status - команда, которая показывает информацию о текущем состоянии репозитория: актуальна ли информация на нём, нет ли чего-то нового, что поменялось, и так далее.
Итак вводим команду в терминал:
```
git status
```
## 6. Запись изменений в репозиторий
В git есть концепция области подготовленных файлов. Можно представить ее как холст, на который наносят изменения, которые нужны в коммите. Сперва он пустой, но затем мы добавляем на него файлы (или части файлов, или даже одиночные строчки) командой add и, наконец, коммитим все нужное в репозиторий (создаем слепок нужного нам состояния) командой commit.
Добавим текущий файл:
```
git add git_instruction.md
```
Если нужно добавить всё, что есть в директории (папке) можно использовать команду:
```
git add -a
```
Проверим статус снова:
```
On branch master
Changes to be committed:
  (use "git restore --staged <file>..." to unstage)
        modified:   git_instruction.md
```
Файл ***проиндексирован*** и готов к коммиту(фиксация изменений). Сообщение о состоянии также говорит нам о том, какие изменения относительно файла были проведены в области подготовки.
## 7. Фиксация изменений
### Как сделать коммит
Представим, что нам нужно добавить пару новых блоков в html-разметку (index.html) и стилизовать их в файле style.css. Для сохранения изменений, их необходимо закоммитить. Но сначала, мы должны обозначить эти файлы для Гита, при помощи команды git add, добавляющей (или подготавливающей) их к коммиту. Добавлять их можно по отдельности:
```
git add index.html
git add css/style.css
```
или вместе - всё сразу:
```
git add .
```
Добавлять всё сразу удобнее, чем прописывать каждую позицию отдельно. Однако, тут надо быть внимательным, чтобы не добавить по ошибке ненужные элементы.

Теперь создадим сам коммит:
```
git commit -m '6. Подготовка файлов и фиксация изменений'
```
Флажок -m задаст commit message - комментарий разработчика. Он необходим для описания закоммиченных изменений. И здесь работает золотое правило всех комментариев в коде: «Максимально ясно, просто и содержательно обозначь написанное!»

## 8. Как сравнить с изменения с последним коммитом

Для вывода изменений в файлах по сравнению с последним коммитом, используется git diff без параметров:
```
git diff
```
Если вы изменили какие-нибудь файлы в вашем рабочем каталоге и добавили один или несколько из них в индекс (с помощью git add), то команда git diff не покажет изменения в этих файлах. Чтобы показать изменения в файлах, включая файлы, добавленные в индекс, используется ключ --cached:
```
git diff --cached
```

## 9. Как посмотреть список коммитов
Для просмотра все выполненных фиксаций можно воспользоваться историей коммитов. Она содержит сведения о каждом проведенном коммите проекта. Запросить ее можно при помощи команды:
```
git log
```
сокращенная версия этой же команды:
```
git log --oneline
```
## 10. Просмотр версий и перемещение между коммитами
Чтобы просмотреть одну из предыдущих версий файла можно ввести команду:
```
git log
```
выбрать нужный коммит и ввести:
```
git checkout номер коммита
```

теперь возможно поработать с этим файлом или скопировать его. 

Для возврата к актуальной версии вводим команду:
```
git switch master
```
или
```
git checkout master
```
##  11. Игнорирование файлов
Каждый из файлов в любом текущем рабочем репозитории Git относится к одному из трех типов:
* Отслеживаемые – это все файлы и каталоги, о которых знает Git. Это файлы и каталоги, которые были недавно размещены (добавлены с помощью git add) и зафиксированы (закоммичены с помощью git commit) в главном репозитории.
* Неотслеживаемые – это новые файлы и каталоги, которые созданы в рабочем каталоге, но еще не размещены (или добавлены с помощью команды git add).
* Игнорируемые – это все файлы и каталоги, которые полностью исключаются и игнорируются, и никто о них в репозитории Git не знает. По сути, это способ сообщить Git о том, какие неотслеживаемые файлы так и должны остаться неотслеживаемыми и не должны фиксироваться.

Все файлы, которые должны быть проигнорированы, сохраняются в файле **.gitignore.**

Для того, чтобы исключить из отслежевания в репозитории определенные файлы и папки необходимо создать там файл **_.gitignore_** и записать в него их названия или шаблоны, соответствующие таким файлам или папкам.
Например, принято не добавлять к отслеживанию крупные файлы (например картинки). Мы можем сразу исключить _все_ файлы с расширением _png_ или _jpeg_. Для этого создаем файл **_.gitignore_** и пишем:
```
*.jpeg
*.png
```
Этот шаблон позволит игнорировать все файлы, оканчивающиеся на _.jpeg_ и _.png_, но вы, например, не хотите, чтобы Git игнорировал файл README.md.

Для этого вам нужно будет воспользоваться шаблоном с отрицанием (с восклицательным знаком), чтобы исключить файл, который в противном случае был бы проигнорирован, как и все остальные:

 игнорирует все файлы .png
 ```
.png
```
не игнорирует файл example.png
```
!example.png     
```
## 12. Создание веток в Git
![](gitbranch.png)
Под веткой принято понимать независимую последовательность коммитов в хронологическом порядке. Однако конкретно в Git реализация ветки выполнена как указатель на последний коммит в рассматриваемой ветке. После создания ветки уже новый указатель ссылается на текущий коммит.
Имя основной ветки Git-проекта по умолчанию — **master** (однако зачастую бывает *main*, например, в GitHub), она появляется сразу при инициализации репозитория.
### Команда **_git branch_**
Команда git branch — главный инструмент для работы с ветвлением. С ее помощью можно добавлять новые ветки, перечислять и переименовывать существующие и удалять их.


Создать ветку можно командой:
```
git branch <branch_name>
```
После данной операции ветка уже была создана, но вы по-прежнему находитесь в прежней ветке. Если вы планируете переместиться на другую ветку, в том числе только что созданную, необходимо написать:
```
git checkout <branch_name>
```
Чаще всего при создании новой ветки git пользователю необходимо сразу же переключиться на нее. В таком случае стоит использовать:
```
git checkout branch <branch_name>
```
Это будет равносильно:
```
git branch <branch_name>
git checkout <branch_name>
```
И также мы получим тот же результат при использовании git checkout с ключом -b и git switch с ключом -с:
```
git checkout -b <branch_name>
git switch -c <branch_name>
```
Список веток в репозитории можно посмотреть с помощью команды: 
```
git branch
```
Текущая ветка будет отмечена (*):
```
* master
```
## 13. Слияние веток
Ветвление позволяет разделять рабочий процесс, оптимизировать тестирование и написание нового кода. После того, как разработчик убедился, что написанный им кусок кода готов (сохранен и закоммичен) и его можно отправить к остальной части итоговой версии, переместив его в основную ветку. 
Для этого в Git предусмотрено слияние — перенос изменений с одной ветки на другую. Однако **_сливаемая ветка_** (у которой берем изменения для «вливания» их в другую ветвь) **_никак не меняется_** и остается в прежнем состоянии. Такие преобразования мы получаем, применив git merge:
```
git merge <name of merged branch>
```
Операция может привести к появлению **_конфликтов_** при попытке слить ветки. Это вызвано тем, что изменения удаляют или переписывают информацию в существующих файлах. При попытке некорректного слияния Git останавливает выполнение команды, чтобы вы могли разрешить конфликт.
Решить конфликт можно двумя способами:

* Вручную разрешить файловый конфликт. Для этого нужно самим изменить файлы, с которыми возникли проблемы. Мы получим файлы такими, какими и представляли их при попытке слияния.
* Выбрать более подходящий файл, а от второго отказаться.
необходимо выполнить коммит слияния

После того, как конфликт слияния решен, **необходимо выполнить коммит слияния**, для этого необходимо выполнить команды:
```
git add <branch name>
git commit -m 'commit info'

## 10. Удаление веток